# -*- coding: utf-8 -*-
"""cap_cocked_md.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xczMvZ4yyOgus4KK-K7JR0umyxKm0bSk
"""

import cv2
import math
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from skimage.draw import ellipse
from skimage.measure import label, regionprops, regionprops_table
from skimage.transform import rotate

import PIL
from PIL import ImageEnhance
from PIL import Image

import cv2
import math
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from skimage.draw import ellipse
from skimage.measure import label, regionprops, regionprops_table
from skimage.transform import rotate

import PIL
from PIL import ImageEnhance
from PIL import Image


def cap_cocked_md(path):
    size = "md"
    # path = "web104.jpg"

    # path = "web83.jpg" outier
    # path = "web_81.jpg"
    # path = "web_82.jpg"
    # path = "web44.jpg"
    # path = "web41.jpg"

    image_c = cv2.imread(path)
    image_c = np.rot90(np.rot90(image_c))

    image = cv2.imread(path,0)
    image = np.rot90(np.rot90(image))

    # print(type(image))
    # print(image.shape)

    # plt.figure(figsize=(10,10))
    # plt.imshow(cv2.cvtColor(image_c,cv2.COLOR_BGR2RGB))

    # crop image
    # crop image
    if size == "lg":
        image_c = image_c[1000:,800:2500]
        image = image[1000:,800:2500]
    elif  size == "md":
        image_c = image_c[1000:,800:2500]
        image= image[1000:,800:2500]
    elif  size == "sm":
        image_c = image_c[500:,800:2500]
        image = image[500:,800:2500]
        
    # plt.imshow(cv2.cvtColor(image_c,cv2.COLOR_BGR2RGB))

    img = image
    img = cv2.medianBlur(img,5)

    ret,th1 = cv2.threshold(img,80,255,cv2.THRESH_BINARY)

    titles = ['org','Global Thresholding (v = 127)'
                ]
    images = [img, th1]
    # assert len(titles)==len(images)
    # for i in range(len(titles)):
    #     plt.subplot(2,2,i+1),plt.imshow(images[i],'gray')
    #     plt.title(titles[i])
    #     plt.xticks([]),plt.yticks([])
    # plt.show()

    bbox = cv2.boundingRect(th1)
    x, y, w, h = bbox

    if size == "lg":
        cropped = cv2.cvtColor(image_c[y-30:y+h+30, x:x+w], cv2.COLOR_BGR2RGB)

    if size == "md":
        cropped = cv2.cvtColor(image_c[y-160:y+h+30, x:x+w], cv2.COLOR_BGR2RGB)

    if size == "sm":
        cropped = cv2.cvtColor(image_c[y-160:y+h+30, x:x+w], cv2.COLOR_BGR2RGB)

    # cropped = cv2.cvtColor(image_c[y:y+h, x:x+w], cv2.COLOR_BGR2RGB)
        
    # plt.figure(figsize=(10,10))
    # plt.imshow(cropped,'gray',vmin=0,vmax=255)
    # plt.show()

    h,w, _ = cropped.shape
    md_crop_ratio =  0.65
    sm_crop_ratio = 0.8
    lg_crop_ratio = 0.5

    # h1 = int(h * 0.24)
    if size == "lg":
        h1 = int(h * lg_crop_ratio)
    elif  size == "md":
        h1 = int(h * md_crop_ratio)
    elif  size == "sm":
        h1 = int(h * sm_crop_ratio)
    # h1 = int(h * 0.55)
    cap_only = cropped[0:h1,:]
    # plt.imshow(cap_only)

    img = cv2.cvtColor(cap_only,cv2.COLOR_BGR2GRAY)
    # plt.figure(figsize = (10,10))
    t = 130
    ret,thresh1 = cv2.threshold(img,t,255,cv2.THRESH_BINARY)
    ret,thresh2 = cv2.threshold(img,t,255,cv2.THRESH_BINARY_INV)
    ret,thresh3 = cv2.threshold(img,t,255,cv2.THRESH_TRUNC)
    ret,thresh4 = cv2.threshold(img,t,255,cv2.THRESH_TOZERO)
    ret,thresh5 = cv2.threshold(img,t,255,cv2.THRESH_TOZERO_INV)
    titles = ['Original Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV']
    images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]
    # for i in range(6):
    #     plt.subplot(2,3,i+1),plt.imshow(images[i],'gray',vmin=0,vmax=255)
    #     plt.title(titles[i])
    #     plt.xticks([]),plt.yticks([])
    # plt.show()

    # thresh4

    pixels = thresh4 == 255
    # print(pixels///000)
    # print(len(pixels))

    blurred = cv2.medianBlur(cap_only,9) # increase kernel size to remove white edges
    test2 = cv2.cvtColor(blurred, cv2.COLOR_RGB2GRAY)
    # t = 20
    t = 40
    # t = 60

    edges = cv2.Canny(test2,t/3,t) # no diff of running this filter, it is justing inverting it


    # plt.figure(figsize=(20, 20), dpi=80)

    # plt.subplot(1,4,1),plt.imshow(edges,'gray')

    lines = cv2.HoughLines(edges, 1, np.pi / 150, 100, None, 0,0)
    thetas = []
    if lines is not None:
        for i in range(0, len(lines)):
            rho = lines[i][0][0]
            theta = lines[i][0][1]
    #         print(rho)
    #         print(theta)
            if  rho > 600 and rho < 800  :
                theta = lines[i][0][1]
                thetas.append(theta)


    # print(thetas)
    theta_min = min(thetas)
    theta_max = max(thetas)

    cdst = cap_only.copy()

    # Draw the lines
    if lines is not None:
        for i in range(0, len(lines)):
            rho = lines[i][0][0]
            theta = lines[i][0][1]
            if  rho > 600 and rho < 800 and (theta == theta_min or theta==theta_max):
                # print("rho : {}   theta:{}".format(rho, theta))
                a = math.cos(theta)
                b = math.sin(theta)
                x0 = a * rho
                y0 = b * rho
                pt1 = (int(x0 + 1000*(-b)), int(y0 + 1000*(a)))
                pt2 = (int(x0 - 1000*(-b)), int(y0 - 1000*(a)))
                cv2.line(cdst, pt1, pt2, (0,255,0), 3, cv2.LINE_AA)

    rho_diff = abs(theta_min - theta_max)
    # print(rho_diff)

    test = cap_only.copy()
    font = cv2.FONT_HERSHEY_SIMPLEX

    if rho_diff <=0.2:
        a = "Acceptable"
        # print("ACCEPTABLE")
        # cv2.putText(cdst, a, (40,100), font, 2, (0, 255, 0), 2, cv2.LINE_AA)

    else:
        a = "Unacceptable"
        # print("UNACCEPTABLE")
        # cv2.putText(cdst, a, (40,100), font, 2, (255, 0, 0), 2, cv2.LINE_AA)

    # plt.imshow(cdst)

    return a



















