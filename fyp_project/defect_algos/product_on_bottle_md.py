# -*- coding: utf-8 -*-
"""feat_match_ensemble_md.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/168Jk4r08fgyEh8-1MyiKUJSheQJAh5JA
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
# import imutils
import math


def product_on_bottle_md(image_name):

    temp = cv2.imread("fyp_project/defect_algos/patch1.jpg",0) # best
    # temp = cv2.imread("patch5.jpg",0) # woorks only on web 114
    size = "md"
    font = cv2.FONT_HERSHEY_SIMPLEX

    # web102,web103 not working fine
    path = image_name

    image_c = cv2.imread(path)
    image_c = np.rot90(np.rot90(image_c))

    image = cv2.imread(path,0)
    image = np.rot90(np.rot90(image))


    # crop image
    if size == "lg":
        image_c = image_c[500:,800:2500]
        image = image[500:,800:2500]
    elif  size == "md":
        image_c = image_c[1000:,800:2500]
        image= image[1000:,800:2500]
    elif  size == "sm":
        image_c = image_c[500:,800:2500]
        image = image[500:,800:2500]
        
    # plt.imshow(cv2.cvtColor(image_c,cv2.COLOR_BGR2RGB))

    img = image
    img = cv2.medianBlur(img,5)

    ret,th1 = cv2.threshold(img,80,255,cv2.THRESH_BINARY)

    titles = ['org','Global Thresholding (v = 127)'
                ]
    images = [img, th1]
    # assert len(titles)==len(images)
    # for i in range(len(titles)):
    #     plt.subplot(2,2,i+1),plt.imshow(images[i],'gray')
    #     plt.title(titles[i])
    #     plt.xticks([]),plt.yticks([])
    # plt.show()

    bbox = cv2.boundingRect(th1)
    x, y, w, h = bbox

    if size == "lg":
        cropped = cv2.cvtColor(image_c[y-30:y+h+30, x:x+w], cv2.COLOR_BGR2RGB)

    if size == "md":
        cropped = cv2.cvtColor(image_c[y-160:y+h+30, x:x+w], cv2.COLOR_BGR2RGB)

    if size == "sm":
        cropped = cv2.cvtColor(image_c[y-160:y+h+30, x:x+w], cv2.COLOR_BGR2RGB)

    # cropped = cv2.cvtColor(cropped, cv2.COLOR_BGR2RGB)
        
    # plt.figure(figsize=(10,10))
    # plt.imshow(cropped,'gray',vmin=0,vmax=255)
    # plt.show()

    h,w, _ = cropped.shape
    md_crop_ratio =  0.65
    sm_crop_ratio = 0.8
    lg_crop_ratio = 0.5

    # h1 = int(h * 0.24)
    if size == "lg":
        h1 = int(h * lg_crop_ratio)
    elif  size == "md":
        h1 = int(h * md_crop_ratio)
    elif  size == "sm":
        h1 = int(h * sm_crop_ratio)
    # h1 = int(h * 0.55)
    cap_only = cropped[0:h1,:]
    # plt.imshow(cap_only)

    test = cv2.cvtColor(cap_only, cv2.COLOR_RGB2GRAY)

    # plt.subplot(121),plt.imshow(test,cmap = 'gray')
    # plt.title('Test Image'), plt.xticks([]), plt.yticks([])
    # plt.subplot(122),plt.imshow(temp,cmap = 'gray')
    # plt.title('Template Image'), plt.xticks([]), plt.yticks([])

    img = test.copy()
    result_img = cap_only.copy()

    match_thresh = {'cv2.TM_CCOEFF':510000,'cv2.TM_CCOEFF_NORMED':0.86}
    # methods = ['cv2.TM_CCOEFF', 'cv2.TM_CCOEFF_NORMED', 'cv2.TM_CCORR','cv2.TM_CCORR_NORMED', 'cv2.TM_SQDIFF', 'cv2.TM_SQDIFF_NORMED']
    methods = ['cv2.TM_CCOEFF', 'cv2.TM_CCOEFF_NORMED']
    patches = ['fyp_project/defect_algos/patch_md_2.jpg','fyp_project/defect_algos/patch_md_6.jpg','fyp_project/defect_algos/patch_md_21.jpg','fyp_project/defect_algos/patch1.jpg','fyp_project/defect_algos/patch3.jpg','fyp_project/defect_algos/patch5.jpg','fyp_project/defect_algos/patch8.jpg','fyp_project/defect_algos/patch10.jpg','fyp_project/defect_algos/patch12.jpg','fyp_project/defect_algos/patch14.jpg',]
    #patches = ['patch_md_6.jpg']
    match_scores = {}
    match_cords = {}
    all_match_scores = {}

    thresh_match_scores = {}
    thresh_match_cords = {}


    for meth in methods:
        method = eval(meth)
        
        for patch in patches:
        
            template = cv2.imread(patch,0)
            w, h = template.shape[::-1]


            res = cv2.matchTemplate(img,template,method)
            min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)
            top_left = max_loc
            bottom_right = (top_left[0] + w, top_left[1] + h)

        #     check to ignore cocked cap area
            #if top_left[0] >= 700 or top_left[1] >= 280 :
            if top_left[0] >= 400 and top_left[1] >= 500 :

                match_scores[meth] = 0
                match_cords[meth] = [top_left, bottom_right]
                all_match_scores[(meth, patch)] = 0           

            else:
                cv2.rectangle(result_img,top_left, bottom_right, 255, 2)
                match_scores[meth] = max_val
                match_cords[meth] = [top_left, bottom_right]
                all_match_scores[(meth, patch)] = max_val
                if max_val > match_thresh['cv2.TM_CCOEFF']:
                    print('yes', (meth, patch))
                    thresh_match_scores[(meth, patch)] = max_val
                    thresh_match_cords[(meth, patch)] = [top_left, bottom_right]
                print(float(str(max_val)[:4]), '@@@~')
                if float(str(max_val)[:4]) > match_thresh['cv2.TM_CCOEFF_NORMED'] and max_val<1:
                    thresh_match_scores[(meth, patch)] = max_val
                    thresh_match_cords[(meth, patch)] = [top_left, bottom_right]

    thresh_match_scores
    #thresh_match_cords
    #top_left[1]



    ccoeff = {}
    ccoeff_norm = {}
    max_match_patch_ccoeff = 0
    max_match_patch_ccoeff_norm = 0

    if bool(thresh_match_scores) is True: ##empty dictionary is false
        for i in thresh_match_scores:
            #print(i)
            if 'cv2.TM_CCOEFF' == i[0]:
                ccoeff[i] = thresh_match_scores[i]
            if 'cv2.TM_CCOEFF_NORMED'== i[0]:
                ccoeff_norm[i] = thresh_match_scores[i]

            
        if len(list(ccoeff_norm)) != 0:
            max_match_patch_ccoeff_norm = max(ccoeff_norm, key=ccoeff_norm.get)
        if len(list(ccoeff)) != 0:
            max_match_patch_ccoeff = max(ccoeff, key=ccoeff.get)
    else:
        print('empty')

        
    #max(thresh_match_scores, key=thresh_match_scores.get)
    max_match_patch_ccoeff_norm

    all_match_scores

    final_img = cap_only.copy()
    result = "ACCEPTABLE"


    if max_match_patch_ccoeff_norm !=0:
        result = "UNACCEPTABLE"
        ## for drawing only one bbox with max match_score
        bbox = thresh_match_cords[max_match_patch_ccoeff_norm]
        cv2.rectangle(final_img,bbox[0], bbox[1], 255, 2)
        cv2.putText(final_img, max_match_patch_ccoeff_norm[1], (bbox[0][0]-150, bbox[0][1]-10), font, 1, 255, 2, cv2.LINE_AA)

    ##maybe CCOEFF gives more FP so keep it as elif
    # if max_match_patch_ccoeff != 0:
    #     result = "UNACCEPTABLE"
    #     ## for drawing only one bbox with max match_score
    #     bbox = thresh_match_cords[max_match_patch_ccoeff]
    #     cv2.rectangle(final_img,bbox[0], bbox[1], 255, 2)
    #     cv2.putText(final_img, max_match_patch_ccoeff[1], (bbox[0][0]-150, bbox[0][1]-10), font, 1, 255, 2, cv2.LINE_AA)

        
        ## for drawing all bboxes
        # for i in thresh_match_cords.keys():
        #     bbox = thresh_match_cords[i]
        #     print(bbox)
        #     cv2.rectangle(final_img,bbox[0], bbox[1], 255, 2)
        #     cv2.putText(final_img, i[0], (bbox[0][0]-150, bbox[0][1]-10), font, 1, 255, 2, cv2.LINE_AA)
          
            
    ## to draw 1 big bbox in case of multiple matches        
    '''thresh_match_cords.values()
    list_match = []
    for i in thresh_match_cords.values():
        list_match +=i
        
    print(list_match)
    min_y = 10000
    max_x = -1
    for cord in list_match:
        if cord[1] < min_y:
            min_y = cord[1]
            min_cord = cord
            
        if cord[0] > max_x:
            max_x = cord[0]
            max_cord = cord
    print(min_cord, max_cord)                    
    cv2.rectangle(final_img,min_cord, max_cord, 255, 2)'''

    # display status
    cv2.putText(final_img, result, (10,100), font, 1, (0, 255, 0), 2, cv2.LINE_AA)
    # show all
    # print("match_thresholds : {}\n".format(match_thresh))
    # print('method and patch selected', max_match_meth_patch, '\n')
    # print('bbox',thresh_match_cords.get(max_match_meth_patch), '\n')

    #print("match_scores : {}\n".format(max_match_meth_patch))
    # print("individual_results : {}\n".format(results))

    # plt.imshow(final_img)

    # plt.imshow(final_img[500:,400:])



    # plt.imshow(final_img[450:,600:]
    # cv2.TM_CCOEFF_NORMED

    # defected : 0.99, 0.88, 0.87, (one image has product but detects glare, so outlier)


    # not defected : 0.76,0.82,0.81,0.83, 0.82, 0.82

    # threshold => 0.85

    # cv2.TM_CCOEF


    # DEFECTED:
    # -873462.0 466366.34375 ( has product but detects glare so outier)
    # -858357.75 568136.75
    # -906090.9375 536627.1875
    # -877573.5625 643408.75

    # NOT DEFECTED:
    # -892298.125 503610.75
    # -962868.5 493864.875
    # -954833.1875 484790.625
    # -891210.875 481419.65625
    # -908925.5 453590.3125


    # plt.imshow(final_img[280:,700:])

    if result == "ACCEPTABLE":
        return "Acceptable"
    else:
        return "Unacceptable"









